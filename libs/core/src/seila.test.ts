import { Model, belongsToMany, belongsToOne, hasMany, hasOne } from './model'
import { build } from './operation-builder'
import { Infer, number, object, oneOf, string } from './schema'

function uuid() {
  return string().primaryKey().autoGenerated('uuid')
}

const AccountSchema = object({
  id: uuid(),
  name: string().unique().length({ max: 64 }),
  type: oneOf(['person', 'company']),
  balance: number().positive(),
})

hasMany

class AccountModel extends Model<typeof AccountSchema> {
  document = hasOne(() => tables.documents)
  bankAccount = hasOne(() => tables.bankAccounts)
}

const DocumentSchema = object({
  id: uuid(),
  number: string().unique().length({ max: 64 }),
  type: oneOf(['cpf', 'passport']),
})

class DocumentModel extends Model<typeof DocumentSchema> {
  user = belongsToOne(() => tables.users)
  accounts = belongsToMany(() => tables.accounts)
}

const BankAccountSchema = object({
  id: uuid(),
  bankId: string().length({ max: 16 }).unique('fullAccountId'),
  branchId: string().length({ max: 32 }).unique('fullAccountId'),
  accountId: string().length({ max: 64 }).unique('fullAccountId'),
})

class BankAccountModel extends Model<typeof BankAccountSchema> {
  user = belongsToOne(() => tables.users)
  accounts = belongsToOne(() => tables.accounts)
}

const UserSchema = object({
  id: uuid(),
})
class UserModel extends Model<typeof UserSchema> {}

const DepositSchema = object({
  id: uuid(),
  value: number().positive(),
})
class DepositModel extends Model<typeof DepositSchema> {
  account = belongsToOne(() => tables.accounts)
}

const TransferSchema = object({
  id: uuid(),
  value: number().positive(),
})
class TransferModel extends Model<typeof TransferSchema> {
  fromAccount = belongsToOne(() => tables.accounts)
  toAccount = belongsToOne(() => tables.accounts)
}

const tables = {
  accounts: new AccountModel(AccountSchema),
  bankAccounts: new BankAccountModel(BankAccountSchema),
  deposits: new DepositModel(DepositSchema),
  documents: new DocumentModel(DocumentSchema),
  transfers: new TransferModel(TransferSchema),
  users: new UserModel(UserSchema),
}

const $ = build(tables)

const createAccount = $.create('accounts').with('bankAccount').with('document')

type PaginationConfig = {
  maxPageSize: number
}
function pagination(config: PaginationConfig) {
  return object({
    pageSize: integer()
      .positive()
      .lessThanOrEqual(config.maxPageSize)
      .default(1),
    page: integer().positive().default(1),
  })
}

const listAccounts = $.using(pagination({ maxPageSize: 1000 })).do((page) =>
  $.from('accounts').inlcude('bankAccount').include('document').getPage(page)
)

const deposit = $.using(
  object({
    accountId: string(),
    value: number().positive(),
  })
).do(async (deposit) => {
  await $.create('deposits')
    .withReferenceTo('account')
    .execute({
      value: deposit.value,
      account: {
        id: deposit.accountId,
      },
    })
  await $.update('accounts')
    .filter((account) => account.id.equal(deposit.accountId))
    .set('balance', (account) => account.balance.plus(deposit.value))
    .execute()
})

const transfer = $.using(
  object({
    fromAccountId: string(),
    toAccountId: string(),
    value: number().positive(),
  })
).do(async (transfer) => {
  await $.create('transfers')
    .withReferenceTo('fromAccount')
    .withReferenceTo('toAccount')
    .execute({
      value: transfer.value,
      fromAccount: {
        id: transfer.fromAccountId,
      },
      toAccount: {
        id: transfer.toAccountId,
      },
    })

  await $.update('accounts')
    .filter((account) => account.id.equal(transfer.fromAccountId))
    .set('balance', (account) => account.balance.minus(transfer.value))

  await $.update('accounts')
    .filter((account) => account.id.equal(transfer.toAccountId))
    .set('balance', (account) => account.balance.plus(transfer.value))
})

const n = {
  '/accounts/create': createAccount,
  '/accounts/list': listAccounts,
  '/deposit': deposit,
  '/transfer': transfer,
}
