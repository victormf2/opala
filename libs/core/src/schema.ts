/* eslint-disable @typescript-eslint/no-explicit-any */
export type SchemaConfig = {
  isOptional?: boolean;
};
export abstract class Schema<
  T = unknown,
  TConfig extends SchemaConfig = SchemaConfig
> {
  // Branding
  private readonly _value?: T;
  optional(): this & OptionalSchema {
    return new (this.constructor as any)({
      ...this.config,
      isOptional: true,
    });
  }

  constructor(readonly config: TConfig) {}
}

export type Infer<S> = S extends Schema<infer T> ? T : never;

export type Shape = {
  [k: string | symbol]: Schema<unknown>;
};
export type ShapeObject<S extends Shape> = {
  [K in keyof S]: Infer<S[K]>;
};

export class ObjectSchema<TShape extends Shape = Shape> extends Schema<
  ShapeObject<TShape>,
  SchemaConfig & {
    shape: TShape;
  }
> {
  constructor(config: { shape: TShape }) {
    super(config);
  }
  extend<TOverrideShape extends Shape>(
    overrideShape: TOverrideShape
  ): ObjectSchema<TShape & TOverrideShape> {
    const newShape = {
      ...this.config.shape,
      ...overrideShape,
    };
    return new ObjectSchema({
      ...this.config,
      shape: newShape,
    });
  }

  omit<Keys extends (keyof TShape)[]>(
    ...keys: Keys
  ): ObjectSchema<Omit<TShape, Keys[number]>> {
    const newShape = {} as any;
    for (const key in this.config.shape) {
      if (!keys.includes(key)) {
        newShape[key] = this.config.shape[key];
      }
    }
    return new ObjectSchema({
      ...this.config,
      shape: newShape,
    });
  }

  pick<Keys extends (keyof TShape)[]>(
    ...keys: Keys
  ): ObjectSchema<Pick<TShape, Keys[number]>> {
    const newShape = {} as any;
    for (const key in this.config.shape) {
      if (keys.includes(key)) {
        newShape[key] = this.config.shape[key];
      }
    }
    return new ObjectSchema({
      ...this.config,
      shape: newShape,
    });
  }
}
export function object<S extends Shape>(shape: S): ObjectSchema<S> {
  return new ObjectSchema({ shape });
}

export type ObjectSchemaAny = ObjectSchema<Shape>;

export type ArraySchemaItem<RS extends ArraySchema> = Infer<RS>[number];
export class ArraySchema<S extends Schema = Schema> extends Schema<
  Infer<S>[],
  SchemaConfig & { itemSchema: S }
> {}
export function array<S extends Schema>(itemSchema: S): ArraySchema<S> {
  return new ArraySchema({ itemSchema });
}

export class StringSchema extends Schema<string> {}
export function string(): StringSchema {
  return new StringSchema({});
}

export class NumberSchema extends Schema<
  number,
  SchemaConfig & { isAutoGenerated: boolean }
> {
  constructor(
    config = {
      isAutoGenerated: false,
    }
  ) {
    super(config);
  }

  autoGenerated(): this & AutoGeneratedSchema {
    return new (this.constructor as any)({
      ...this.config,
      isAutoGenerated: true,
    });
  }
}
export function number(): NumberSchema {
  return new NumberSchema();
}

export type AutoGeneratedSchema = {
  config: {
    isAutoGenerated: true;
  };
};

export type OptionalSchema = {
  config: {
    isOptional: true;
  };
};

export function canBeAutoGenerated(
  schema: Schema
): schema is Schema & { config: { isAutoGenerated: boolean } } {
  return schema instanceof NumberSchema;
}
