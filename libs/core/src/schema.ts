export abstract class Schema<T = unknown> {
  // Branding Schema class
  private readonly _value = null as unknown as T;
}

type SchemaReference<T> = () => Schema<T>;
export type Infer<S> = S extends Schema<infer T> ? T : never;

export type Shape = {
  [k: string | symbol]: Schema<unknown> | SchemaReference<unknown>;
};
export type ShapeObject<S extends Shape> = {
  [K in keyof S]: Infer<S[K]>;
};

export class ObjectSchema<TShape extends Shape = Shape> extends Schema<
  ShapeObject<TShape>
> {
  constructor(readonly shape: TShape) {
    super();
  }
  extend<TOverrideShape extends Shape>(
    overrideShape: TOverrideShape
  ): ObjectSchema<TShape & TOverrideShape> {
    const newShape: TShape & TOverrideShape = {
      ...this.shape,
      ...overrideShape,
    };
    return new ObjectSchema(newShape);
  }
  omit<Keys extends (keyof TShape)[]>(
    ...keys: Keys
  ): ObjectSchema<Omit<TShape, Keys[number]>> {
    const newShape: Shape = {};
    for (const key in this.shape) {
      if (!keys.includes(key)) {
        newShape[key] = this.shape[key];
      }
    }
    return new ObjectSchema(newShape as Omit<TShape, Keys[number]>);
  }
  pick<Keys extends (keyof TShape)[]>(
    ...keys: Keys
  ): ObjectSchema<Pick<TShape, Keys[number]>> {
    const newShape: Shape = {};
    for (const key in this.shape) {
      if (keys.includes(key)) {
        newShape[key] = this.shape[key];
      }
    }
    return new ObjectSchema(newShape as Pick<TShape, Keys[number]>);
  }
}
export function object<S extends Shape>(
  ...args: ConstructorParameters<typeof ObjectSchema<S>>
) {
  return new ObjectSchema(...args);
}
export type ObjectSchemaAny = ObjectSchema<Shape>;

export type ArraySchemaItem<RS extends ArraySchema> = Infer<RS>[number];
export class ArraySchema<S extends Schema = Schema> extends Schema<Infer<S>[]> {
  constructor(readonly itemSchema: S) {
    super();
  }
}
export function array<S extends Schema>(
  ...args: ConstructorParameters<typeof ArraySchema<S>>
) {
  return new ArraySchema(...args);
}

export class StringSchema extends Schema<string> {}
export function string() {
  return new StringSchema();
}

type NumberSchemaConfig = {
  isAutoGenerated: boolean;
  isPrimaryKey: boolean;
};
export class NumberSchema extends Schema<number> {
  constructor(
    readonly config: NumberSchemaConfig = {
      isAutoGenerated: false,
      isPrimaryKey: false,
    }
  ) {
    super();
  }

  autoGenerated(): this & AutoGeneratedSchema {
    return new NumberSchema({
      ...this.config,
      isAutoGenerated: true,
    }) as this & AutoGeneratedSchema;
  }
}
export function number(): NumberSchema {
  return new NumberSchema();
}

export type AutoGeneratedSchema = {
  config: {
    isAutoGenerated: true;
  };
};
