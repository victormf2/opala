import { KeysOfType, PartialByKey } from '@app-builder/utils';
import {
  BaseReference,
  HasMany,
  Model,
  ModelReferenceKeys,
  ModelShape,
  ModelType,
  PrimaryKeyShape,
  hasPrimaryKey,
} from './model';
import { Operation } from './operation';
import {
  AutoGeneratedSchema,
  ObjectSchemaAny,
  ShapeObject,
  array,
  canBeAutoGenerated,
  object,
} from './schema';

export class CreateOperation<
  TModel extends Model,
  TInput = CreateAttributes<TModel>
> extends Operation<TInput, unknown> {
  readonly inputSchema: ObjectSchemaAny;
  constructor(readonly model: TModel, inputSchema?: ObjectSchemaAny) {
    super();
    this.inputSchema = inputSchema ?? getInputSchemaFromModel(this.model);
  }

  withReferenceTo<RKey extends ModelReferenceKeys<TModel>>(
    referenceKey: RKey
  ): CreateOperation<TModel, TInput & ReferenceAttributes<TModel, RKey>> {
    const reference = this.model[referenceKey];
    if (!(reference instanceof BaseReference)) {
      throw new Error(`${String(referenceKey)} is not a valid reference`);
    }
    const referencedModel = reference.referencedModel as Model;
    if (!hasPrimaryKey(referencedModel)) {
      throw new Error(
        `Model referenced by ${String(
          referenceKey
        )} does not declare a primaryKey`
      );
    }
    if (reference instanceof HasMany) {
      const primaryKey = referencedModel.primaryKey;
      const primaryKeySchema = referencedModel.schema.pick(...primaryKey);
      return new CreateOperation(
        this.model,
        this.inputSchema.extend({
          [referenceKey]: array(primaryKeySchema),
        })
      );
    }

    throw new Error(`${String(referenceKey)} is not a valid reference`);
  }
}

export type CreateAttributes<TModel extends Model> =
  MakeAutoGeneratedAttributesOptional<TModel>;

export type MakeAutoGeneratedAttributesOptional<TModel extends Model> =
  PartialByKey<
    ModelType<TModel>,
    KeysOfType<ModelShape<TModel>, AutoGeneratedSchema>
  >;

export type ReferenceAttributes<
  TModel extends Model,
  RKey extends ModelReferenceKeys<TModel>
> = {
  [Key in RKey]: TModel[RKey] extends HasMany<infer TReferencedModel>
    ? ShapeObject<PrimaryKeyShape<TReferencedModel>>[]
    : never;
};

function getInputSchemaFromModel<TModel extends Model>(model: TModel) {
  const schema = model.schema;
  const newShape = schema.config.shape;
  for (const key in newShape) {
    const attributeSchema = newShape[key];
    if (canBeAutoGenerated(attributeSchema)) {
      if (attributeSchema.config.isAutoGenerated) {
        newShape[key] = attributeSchema.optional();
      }
    }
  }
  return object(newShape);
}
